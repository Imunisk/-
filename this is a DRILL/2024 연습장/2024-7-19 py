#재귀 - 팩토리얼
def factorial(n):
    if n == 1 or n == 0:
        return 1
    else:
        return n * factorial(n-1)
'''
def fac(n) :
    if n == 1 or n == 0:
        return 1
    else:
        return n*fac(n-1)
def factorial(N):
    if N == 0 or N == 1:
        return 1
    else:
        return N*factorial(N-1)
def fac(num):
    if num == 0 or num == 1:
        return 1
    else:
        return num*fac(num-1)
def f(a):
    if a == 0 or a== 1:
        return 1
    else:
        return a*f(a-1)
def fac(n):
    if n ==0 or n== 1:
        return 1
    else:
        return n*fac(n-1)
def factorial(num):
    if num == 0 or num == 1:
        return 1
    else:
        return n*factoria(num)
def f(num):
    if num ==0 or num == 1:
        return 1
    else:
        return num*f(num-1)
'''
#재귀- 타일 병합정렬

#  n=정수라고 가정하고,
#  2^2n - 1 = (2^n - 1)(2^n + 1)
#  3_number = {2^n -1,  2^n,  2^n +1}
#  세 숫자 2^n -1, 2^n, 2^n +1 은 연달아 있는 세 정수이다.
#  2^n은 3의 배수가 될 수 없다.
#  인수로 3이 아예 없기 때문이다.

n X n 개의 타일이 깔린
정사각형의 공간이 있다.

여기에 4개 값을 지닌 리스트가 있다.
 a, b, c, d
  a,b  c,d

어떻게 병합 정렬이 동작하는지 살펴보자

def mergeSort(L):
    if len(L) == 2:
        ifL[0] <= L[2]]
            return [L[0]. L[1]]
        else:
            return [L[1], L[0]]
    else:
        middle = len(L)//2
        left = mergeSort(L[:middle])
        right = mergeSort(L[middle:])
        return merge(left, right)


def mergeSort(L):
    if len(L) == 2:
        if L[0] <= L[1]:
            return [L[0], L[1]]
        else:
            return [L[1], L[0]]
    else:
        middle = len(L)//2
        left = mergeSort(L[:middle])
        right = mergeSort(L[middle:])
        return merge(left, right)

def mergeSort(L):
    if len(L) == 2:
        if L[0] <= L[1]:
            return [L[0], L[1]]
        else:
            return [L[1], L[0]]
    else:
        middle = len(L)//2
        left = mergeSort(L[:middle])
        right = mergeSort(L[middle:])
        return merge(left, right)

